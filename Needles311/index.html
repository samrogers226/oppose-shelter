<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boston Needle Reports Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
  <!-- Add Chart.js for the yearly reports chart -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <!-- Add Leaflet.heat for heatmap functionality -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>
  <style>
    /* Set full height and use flex layout for body */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Consistent header and navigation styling */
    header {
      background-color: #1a1a1a;
      color: white;
      text-align: center;
      padding: 1.5rem 1rem;
      font-family: 'Playfair Display', serif;
      font-size: 2.5rem;
      letter-spacing: 1px;
      flex: 0 0 auto;
      z-index: 1500;
    }
    nav {
      background-color: #333;
      display: flex;
      justify-content: center;
      padding: 0.5rem;
      flex: 0 0 auto;
    }
    nav a {
      color: #fff;
      margin: 0 1rem;
      text-decoration: none;
      font-size: 1rem;
      transition: transform 0.3s ease;
    }
    nav a:hover {
      transform: scale(1.1);
    }
    /* Remove fixed viewport height from container ‚Äì make it flex-grow */
    .page-container {
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr auto;
      grid-template-areas: 
          "settings"
          "content"
          "controls";
      overflow: hidden;
    }
    .settings-section {
      grid-area: settings;
      background-color: #f5f5f5;
      padding: 10px;
      overflow-y: auto;
      max-height: 30vh;
    }
    .content-section {
      grid-area: content;
      display: grid;
      grid-template-columns: 1fr 350px;
      grid-template-areas: "map info";
      overflow: hidden;
    }
    .controls-section {
      grid-area: controls;
      background-color: #f9f9f9;
      padding: 10px;
    }
    .map-container {
      grid-area: map;
      position: relative;
      height: 100%;
      width: 100%;
    }
    #map {
      height: 100%;
      width: 100%;
      contain: strict;
      will-change: transform;
    }
    .info-panel {
      grid-area: info;
      background-color: #f0f8ff;
      padding: 15px;
      overflow-y: auto;
    }
    @media (max-width: 992px) {
      .page-container {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }
      .settings-section {
        order: 1;
        max-height: none;
        overflow-y: visible;
      }
      .map-settings {
        order: 0;
        margin-top: 0;
        margin-bottom: 15px;
        background-color: #e9f7ff;
        border-radius: 5px;
      }
      .map-container {
        order: 2;
        height: 50vh;
        min-height: 300px;
      }
      .controls-section {
        order: 3;
      }
      .info-panel {
        order: 4;
        max-height: none;
        display: flex;
        flex-direction: column;
      }
      .content-section {
        display: contents;
      }
      .settings-row label {
        width: auto;
        min-width: 120px;
      }
      #addressInput {
        width: 100% !important;
        margin-bottom: 5px;
      }
      #searchAddress {
        margin-left: 0;
      }
      .legend {
        transform: scale(0.6);
        transform-origin: bottom right;
      }
    }
    .controls {
      padding: 10px;
      background-color: #f5f5f5;
    }
    .legend {
      padding: 6px 8px;
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
      line-height: 24px;
      color: #555;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      opacity: 0.7;
    }
    .info {
      padding: 10px;
      background-color: #e3f2fd;
      margin-bottom: 10px;
      border-radius: 4px;
    }
    .animation-controls {
      margin-top: 0;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 4px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }
    .animation-controls button {
      padding: 5px 5px;
      cursor: pointer;
    }
    .time-slider-container {
      flex-grow: 1;
      display: flex;
      align-items: center;
      gap: 0px;
      width: 100%;
    }
    #timeSlider {
      flex-grow: 1;
    }
    .date-display {
      width: 150px;
      text-align: center;
      font-weight: bold;
      overflow: hidden;
      white-space: nowrap;
    }
    .speed-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .settings-panel {
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 4px;
    }
    .settings-panel h3 {
      margin-top: 0;
    }
    .settings-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .settings-row label {
      width: 150px;
    }
    .settings-row input[type="number"] {
      width: 100px;
    }
    .settings-row button {
      margin-left: auto;
      padding: 5px 10px;
    }
    .chart-container {
      width: 100%;
      height: 200px;
      position: relative;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(185px, 1fr));
      gap: 15px;
      margin-bottom: 10px;
    }
    .stat-card {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .stat-card p {
      margin: 5px 0;
    }
    body.animation-active {
      pointer-events: none;
    }
    body.animation-active .animation-controls,
    body.animation-active .settings-panel {
      pointer-events: auto;
    }
    .leaflet-tile-container {
      will-change: transform;
    }
    .leaflet-marker-pane {
      will-change: transform;
    }
    body.animation-active .animation-controls {
      background-color: #e6f7ff;
    }
    /* Dark mode styles */
    body.dark-mode {
      background-color: #222;
      color: #ddd;
    }
    body.dark-mode .settings-section {
      background-color: #333 !important;
      color: #ddd !important;
    }
    body.dark-mode .controls-section {
      background-color: #2a2a2a !important;
      color: #ddd !important;
    }
    body.dark-mode .info-panel {
      background-color: #3a3a3a !important;
      color: #ddd !important;
    }
    body.dark-mode .settings-panel.map-settings {
      background-color: #333 !important;
      border-color: #555;
    }
    body.dark-mode .stat-card {
      background-color: #444 !important;
      border-color: #555;
      color: #ddd !important;
    }
    body.dark-mode .animation-controls {
      background-color: #2a2a2a !important;
      color: #ddd !important;
    }
    @media (max-width: 600px) {
      .stats-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 3px;
      }
      .stat-card {
        padding: 3px;
        font-size: 0.7rem;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <!-- New Header and Navigation -->
  <header role="banner">
    Boston Needle Reports Visualization
  </header>
<nav role="navigation" aria-label="Main Navigation">
  <a href="../index.html">Home</a>
  <a href="https://chng.it/8G642zHkC4">Sign Petition</a>
  <a href="#" onclick="promptEmail()">Join Mailing List</a>
  <a href="../index.html#mailing">Email City Officials</a>
  <a href="#">Needle Visualization</a>
</nav>
<!-- Hidden form for FormSubmit -->
    <form id="mailingListForm" action="https://formsubmit.co/shagainstdn@gmail.com" method="POST" style="display: none;">
      <input type="email" name="email" id="userEmail" required aria-label="Email Address">
      <input type="hidden" name="_subject" value="New Mailing List Signup">
    </form>
	
  <!-- Page container now flex-grows to fill remaining space -->
  <div class="page-container">
    <!-- Content Section (Map and Info) -->
    <div class="content-section">
      <!-- Map Container -->
      <div class="map-container">
        <div id="map"></div>
      </div>
      
      <!-- Info Panel -->
      <div class="info-panel">
        <div class="settings-panel map-settings">
          <h3>Map Settings</h3>
          <div class="settings-row">
            <input type="text" id="addressInput" placeholder="Enter an address" style="width: 300px;">
            <button id="searchAddress">Search</button>
          </div>
          <div class="settings-row">
            <label for="radiusSlider">Radius (miles):</label>
            <input type="range" id="radiusSlider" min="0.1" max="3.1" step="0.05" value="0.25">
            <span id="radiusValue">0.25</span>
          </div>
          <div class="settings-row">
            <label for="toggleHeatmap">Show Heatmap:</label>
            <input type="checkbox" id="toggleHeatmap">
          </div>
          <div class="settings-row">
            <label for="toggleMarkers">Show Markers:</label>
            <input type="checkbox" id="toggleMarkers" checked>
          </div>
          <div id="geocodeStatus" style="margin-top: 5px; color: #666;"></div>
        </div>
        
        <h3>Needle Reports Statistics</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <h4>Total Reports</h4>
            <p id="totalReports">0</p>
          </div>
          <div class="stat-card">
            <h4>Active Locations</h4>
            <p id="activeLocations">0</p>
          </div>
          <div class="stat-card">
            <h4>Recent Reports (30d)</h4>
            <p id="recentReports">0</p>
          </div>
        </div>
        
        <h3>Reports by Year</h3>
        <div class="chart-container">
          <canvas id="yearlyChart"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Controls Section at bottom -->
    <div class="controls-section">
      <div class="animation-controls">
        <button id="playButton">‚ñ∂Ô∏è Play</button>
        <button id="pauseButton" disabled>‚è∏Ô∏è Pause</button>
        <button id="restartButton">üîÑ Restart</button>
        <div class="speed-control">
          <label for="speedControl">Speed:</label>
          <select id="speedControl">
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x</option>
            <option value="2">2x</option>
            <option value="5">5x</option>
            <option value="10">10x</option>
            <option value="25">25x</option>
            <option value="50">50x</option>
          </select>
        </div>
        <div class="time-slider-container">
          <div class="date-display" id="currentDate">-</div>
          <input type="range" id="timeSlider" min="0" max="100" value="0">
          <div class="date-display" id="endDate">-</div>
        </div>
      </div>
    </div>
  </div>

    <script>
        // Initialize with default center coordinates and quarter mile radius
        let CENTER_LAT = 42.32995;
        let CENTER_LNG = -71.11142;
        let RADIUS_MILES = 0.25;
        let RADIUS_METERS = RADIUS_MILES * 1609.34; // Convert miles to meters
        let csvData = []; // Store the CSV data globally
		let globalDateRangeSet = false;

   
		const lightLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://carto.com/">CartoDB</a> &copy; OpenStreetMap contributors',
    subdomains: 'abcd',
    maxZoom: 19
});

const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://carto.com/">CartoDB</a> &copy; OpenStreetMap contributors',
    subdomains: 'abcd',
    maxZoom: 19
});
// Initialize the map with the light layer.
const map = L.map('map', { layers: [lightLayer] }).setView([CENTER_LAT, CENTER_LNG], 16);

// Define the baseMaps object.
const baseMaps = {
    "Light": lightLayer,
    "Dark": darkLayer
};

// Add Leaflet‚Äôs layer control to the map.
L.control.layers(baseMaps).addTo(map);


        // Create a circle for the radius
        let radiusCircle = L.circle([CENTER_LAT, CENTER_LNG], {
            color: '#3388ff',
            fillColor: '#3388ff',
            fillOpacity: 0.0,
            radius: RADIUS_METERS
        }).addTo(map);

        // Create a marker for the center
        let centerMarker = L.marker([CENTER_LAT, CENTER_LNG])
            .bindPopup(`Center: ${CENTER_LAT}, ${CENTER_LNG}`)
            .addTo(map);
            
        // Update map center on movement
        map.on('moveend', function(e) {
            const center = map.getCenter();
            CENTER_LAT = center.lat;
            CENTER_LNG = center.lng;
            radiusCircle.setLatLng([CENTER_LAT, CENTER_LNG]);
            centerMarker.setLatLng([CENTER_LAT, CENTER_LNG])
                .bindPopup(`Center: ${CENTER_LAT.toFixed(5)}, ${CENTER_LNG.toFixed(5)}`);
			if (csvData && csvData.length > 0) {
                processData(csvData);
            }
        });

        // Global heatmap layer (initialized but not added by default)
        let heatLayer = L.heatLayer([], {radius: 25, blur: 15, maxZoom: 17});
        // Listen for heatmap toggle changes
        document.getElementById('toggleHeatmap').addEventListener('change', function(e) {
            if (this.checked) {
                heatLayer.addTo(map);
            } else {
                map.removeLayer(heatLayer);
            }
			processData(csvData);
        });

        // Create markers layer and add it by default
        const markersGroup = L.layerGroup().addTo(map);
        // Listen for marker toggle changes
        document.getElementById('toggleMarkers').addEventListener('change', function(e) {
			if (this.checked) {
				markersGroup.addTo(map);
				// Add the legend if it doesn't already exist.
				if (!map.legend) {
					addLegend();
				}
			} else {
				map.removeLayer(markersGroup);
				// Remove the legend if it exists.
				if (map.legend) {
					map.legend.remove();
					map.legend = null;
				}
			}
		});

        // Map to store reports by location
        const reportsByLocation = new Map();
        // Animation variables
        let allReports = [];
        let startDate = null;
        let endDate = null;
        let currentDate = null;

        // Update UI with current radius
        const initialRadius = parseFloat(document.getElementById('radiusSlider').value);
        document.getElementById('radiusValue').textContent = initialRadius.toFixed(2);

        // Function to check if a point is within radius of center
        function isWithinRadius(lat, lng) {
            if (RADIUS_MILES === -1) {
                return true;
            }
            const center = L.latLng(CENTER_LAT, CENTER_LNG);
            const point = L.latLng(lat, lng);
            return center.distanceTo(point) <= RADIUS_METERS;
        }

        // Removed file input event listener

        // Radius slider event listener
        document.getElementById('radiusSlider').addEventListener('input', function(e) {
            RADIUS_MILES = parseFloat(e.target.value);
            if (RADIUS_MILES >= 3.1) {
                document.getElementById('radiusValue').textContent = "MAX";
                RADIUS_MILES = -1;
                radiusCircle.setStyle({ opacity: 0, fillOpacity: 0 });
            } else {
                document.getElementById('radiusValue').textContent = RADIUS_MILES.toFixed(2);
                RADIUS_METERS = RADIUS_MILES * 1609.34;
                radiusCircle.setRadius(RADIUS_METERS);
                radiusCircle.setStyle({ opacity: 0.8, fillOpacity: 0.0 });
            }
            if (csvData && csvData.length > 0) {
                processData(csvData);
            }
        });

		map.on('baselayerchange', function (event) {
		  if (event.name === "Dark") {
			// Switch the page to dark mode
			document.body.classList.add("dark-mode");
		  } else {
			// Switch the page back to light mode
			document.body.classList.remove("dark-mode");
		  }
		});
		
		    function promptEmail() {
      const email = prompt("Please enter your email to join our mailing list:");
      if (email && validateEmail(email)) {
        document.getElementById('userEmail').value = email;
        document.getElementById('mailingListForm').submit();
      } else if (email) {
        alert("Please enter a valid email address.");
      }
    }

    function validateEmail(email) {
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
	
        // Geocoding functions

        // Function to geocode an address using OpenStreetMap Nominatim
        function geocodeAddress(address) {
            const statusElement = document.getElementById('geocodeStatus');
            statusElement.textContent = "Searching for address...";
            statusElement.style.color = "#666";
            
            // Add Boston, MA to the search query if not already present
            let searchQuery = address;
            if (!searchQuery.toLowerCase().includes("boston") && !searchQuery.toLowerCase().includes("ma")) {
                searchQuery += " Boston, MA";
            }
            
            // Build the Nominatim API URL
            const nominatimUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(searchQuery)}&format=jsonv2&addressdetails=1&limit=1&countrycodes=us&viewbox=-71.2,42.4,-70.9,42.2&bounded=1`;
            
            fetch(nominatimUrl, {
                headers: { 'User-Agent': 'Boston311Visualization/1.0' }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Network error: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lng = parseFloat(result.lon);
                    
                    let displayName = result.display_name;
                    if (displayName.length > 60) {
                        displayName = displayName.substring(0, 60) + "...";
                    }
                    
                    CENTER_LAT = lat;
                    CENTER_LNG = lng;
                    
                    statusElement.textContent = `Found: ${displayName}`;
                    statusElement.style.color = "green";
                    
                    map.setView([lat, lng], 16);
                    radiusCircle.setLatLng([lat, lng]);
                    centerMarker.setLatLng([lat, lng])
                        .bindPopup(`Center: ${lat.toFixed(5)}, ${lng.toFixed(5)}`);
                    
                    if (csvData && csvData.length > 0) {
                        processData(csvData);
                    }
                    return;
                }
                checkLocalDatabase(address, statusElement);
            })
            .catch(error => {
                console.error("Geocoding error:", error);
                tryJSONPNominatim(searchQuery, statusElement);
            });
        }

        // JSONP fallback for Nominatim (to bypass CORS issues)
        function tryJSONPNominatim(searchQuery, statusElement) {
            const callbackName = 'nominatimCallback_' + Math.floor(Math.random() * 1000000);
            const script = document.createElement('script');
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(searchQuery)}&format=json&addressdetails=1&limit=1&countrycodes=us&viewbox=-71.2,42.4,-70.9,42.2&bounded=1&json_callback=${callbackName}`;
            
            window[callbackName] = function(data) {
                document.head.removeChild(script);
                if (data && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lng = parseFloat(result.lon);
                    
                    let displayName = result.display_name;
                    if (displayName.length > 60) {
                        displayName = displayName.substring(0, 60) + "...";
                    }
                    
                    CENTER_LAT = lat;
                    CENTER_LNG = lng;
                    
                    statusElement.textContent = `Found: ${displayName}`;
                    statusElement.style.color = "green";
                    
                    map.setView([lat, lng], 16);
                    radiusCircle.setLatLng([lat, lng]);
                    centerMarker.setLatLng([lat, lng])
                        .bindPopup(`Center: ${lat.toFixed(5)}, ${lng.toFixed(5)}`);
                    
                    if (csvData && csvData.length > 0) {
                        processData(csvData);
                    }
                } else {
                    checkLocalDatabase(searchQuery, statusElement);
                }
                delete window[callbackName];
            };
            
            script.src = url;
            document.head.appendChild(script);
            
            setTimeout(function() {
                if (window[callbackName]) {
                    delete window[callbackName];
                    if (document.head.contains(script)) {
                        document.head.removeChild(script);
                    }
                    checkLocalDatabase(searchQuery, statusElement);
                }
            }, 5000);
        }

        // Fallback to local database for Boston locations
        function checkLocalDatabase(address, statusElement) {
            const bostonLocations = {
                "mission hill": { lat: 42.3295, lng: -71.1045, name: "Mission Hill, Boston, MA" },
                "roxbury": { lat: 42.3298, lng: -71.0892, name: "Roxbury, Boston, MA" },
                "jamaica plain": { lat: 42.3066, lng: -71.1152, name: "Jamaica Plain, Boston, MA" },
                "fenway": { lat: 42.3429, lng: -71.1003, name: "Fenway, Boston, MA" },
                "boston common": { lat: 42.3554, lng: -71.0660, name: "Boston Common, Boston, MA" },
                "dorchester": { lat: 42.2933, lng: -71.0670, name: "Dorchester, Boston, MA" },
                "south boston": { lat: 42.3359, lng: -71.0328, name: "South Boston, MA" },
                "brighton": { lat: 42.3464, lng: -71.1627, name: "Brighton, Boston, MA" },
                "allston": { lat: 42.3509, lng: -71.1324, name: "Allston, Boston, MA" },
                "beacon hill": { lat: 42.3589, lng: -71.0702, name: "Beacon Hill, Boston, MA" },
                "back bay": { lat: 42.3503, lng: -71.0810, name: "Back Bay, Boston, MA" },
                "downtown boston": { lat: 42.3601, lng: -71.0589, name: "Downtown Boston, MA" }
            };
            
            const bostonStreets = {
                "south huntington ave": { lat: 42.3238, lng: -71.1113, name: "South Huntington Avenue, Boston, MA" },
                "s huntington ave": { lat: 42.3238, lng: -71.1113, name: "South Huntington Avenue, Boston, MA" },
                "huntington ave": { lat: 42.3372, lng: -71.0957, name: "Huntington Avenue, Boston, MA" },
                "massachusetts ave": { lat: 42.3418, lng: -71.1021, name: "Massachusetts Avenue, Boston, MA" },
                "mass ave": { lat: 42.3418, lng: -71.1021, name: "Massachusetts Avenue, Boston, MA" },
                "commonwealth ave": { lat: 42.3503, lng: -71.0923, name: "Commonwealth Avenue, Boston, MA" },
                "comm ave": { lat: 42.3503, lng: -71.0923, name: "Commonwealth Avenue, Boston, MA" }
            };
            
            const cleanAddress = address.toLowerCase().trim();
            for (const [key, location] of Object.entries(bostonLocations)) {
                if (cleanAddress.includes(key)) {
                    updateMapLocation(location.lat, location.lng, location.name, statusElement);
                    return;
                }
            }
            for (const [streetKey, location] of Object.entries(bostonStreets)) {
                if (cleanAddress.includes(streetKey)) {
                    updateMapLocation(location.lat, location.lng, location.name, statusElement);
                    return;
                }
            }
            
            statusElement.textContent = "Address not found. Try specifying a Boston location like 'South Huntington Ave, Boston'.";
            statusElement.style.color = "red";
        }

        // Helper function to update the map based on a found location
        function updateMapLocation(lat, lng, displayName, statusElement) {
            CENTER_LAT = lat;
            CENTER_LNG = lng;
            statusElement.textContent = `Found: ${displayName}`;
            statusElement.style.color = "green";
            map.setView([CENTER_LAT, CENTER_LNG], 16);
            radiusCircle.setLatLng([CENTER_LAT, CENTER_LNG]);
            centerMarker.setLatLng([CENTER_LAT, CENTER_LNG])
                .bindPopup(`Center: ${CENTER_LAT.toFixed(5)}, ${CENTER_LNG.toFixed(5)}`);
            if (csvData && csvData.length > 0) {
                processData(csvData);
            }
        }

        // Attach event listeners for address search
        document.getElementById('searchAddress').addEventListener('click', function() {
            const address = document.getElementById('addressInput').value.trim();
            if (address) {
                geocodeAddress(address);
            }
        });
        document.getElementById('addressInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const address = this.value.trim();
                if (address) {
                    geocodeAddress(address);
                }
            }
        });

        function processCSV(file) {
            // Not used anymore, as we load CSV directly via needles_all.csv
            Papa.parse(file, {
                header: true,
                complete: function(results) {
                    csvData = results.data;
                    processData(csvData);
                },
                error: function(error) {
                    console.error('Error parsing CSV:', error);
                    alert('Error parsing CSV file. Please check the format.');
                }
            });
        }

        function processData(data) {
			// Clear previously rendered layers and reports
			markersGroup.clearLayers();
			reportsByLocation.clear();
			allReports = [];

			// 1. Compute the global date range from the entire dataset.
			if (!globalDateRangeSet) {
				const globalDates = [];
				data.forEach(row => {
					if (row.open_dt) {
						// Parse the date without filtering out any rows due to location.
						const dt = moment(row.open_dt, ['M/D/YYYY H:mm', 'M/D/YYYY h:mm']);
						if (dt.isValid()) {
							globalDates.push(dt);
						}
					}
				});
				if (globalDates.length > 0) {
					// Use the earliest and latest dates from the global dataset.
					startDate = moment.min(globalDates).clone().startOf('day');
					endDate = moment.max(globalDates).clone().endOf('day');
					// Force the current date to be the start date.
					currentDate = startDate.clone();

					// Update animation controller with the global date range.
					animationController.setDateRange(startDate, endDate, currentDate);
					const slider = document.getElementById('timeSlider');
					slider.min = 0;
					slider.max = endDate.diff(startDate, 'days');
					slider.value = 0;  // Ensures the slider starts at the earliest date.

					// Always update the end date display.
					document.getElementById('endDate').textContent = endDate.format('MMM D, YYYY');

					globalDateRangeSet = true;
				}
			}

			// 2. Process data for visualization using the current map radius.
			// This block filters based on the location using isWithinRadius.
			data.forEach(row => {
				if (row.latitude && row.longitude && row.open_dt) {
					const lat = parseFloat(row.latitude);
					const lng = parseFloat(row.longitude);
					// Use the isWithinRadius check to determine if the report should be drawn.
					if (!isNaN(lat) && !isNaN(lng) && isWithinRadius(lat, lng)) {
						const date = moment(row.open_dt, ['M/D/YYYY H:mm', 'M/D/YYYY h:mm']);
						if (date.isValid()) {
							const locationKey = `${lat.toFixed(5)},${lng.toFixed(5)}`;
							if (!reportsByLocation.has(locationKey)) {
								reportsByLocation.set(locationKey, {
									lat: lat,
									lng: lng,
									reports: [],
									latestDate: null
								});
							}
							const report = { date: date, locationKey: locationKey, data: row };
							const locationData = reportsByLocation.get(locationKey);
							locationData.reports.push(report);
							if (!locationData.latestDate || date > locationData.latestDate) {
								locationData.latestDate = date;
							}
							allReports.push(report);
						}
					}
				}
			});

			allReports.sort((a, b) => a.date - b.date);

			// 3. Visualize markers and update other UI elements using the pre-established current date.
			visualizeDataAtDate(animationController.currentDate);
			updateYearlyChart(animationController.currentDate);

			setTimeout(() => {
				map.invalidateSize();
			}, 100);
		}





       function addLegend() {
			if (map.legend) {
				map.legend.remove();
			}
			const legend = L.control({position: 'bottomright'});
			legend.onAdd = function (map) {
				const div = L.DomUtil.create('div', 'legend');
				div.innerHTML = '<h4>Legend</h4>' +
					'<i style="background:#e74c3c; border-radius:50%; width:5px; height:5px;"></i> 1 needle report<br>' +
					'<i style="background:#e74c3c; border-radius:50%; width:15px; height:15px;"></i> Multiple reports<br>' +
					'<i style="background:#e74c3c; border-radius:50%; width:25px; height:25px;"></i> Many reports<br>' +
					'<hr>' +
					'<i style="background:#e74c3c; opacity:1.0;"></i> Recent<br>' +
					'<i style="background:#e74c3c; opacity:0.6;"></i> 6 months old<br>' +
					'<i style="background:#e74c3c; opacity:0.2;"></i> 12+ months old';
				return div;
			};
			legend.addTo(map);
			map.legend = legend;
		}

        
        function loadSampleData() {
            const currentDate = moment();
            const sampleData = [];
            function randomDate(start, end) {
                return moment(start.valueOf() + Math.random() * (end.valueOf() - start.valueOf()));
            }
            const locations = [];
            for (let i = 0; i < 5; i++) {
                let pointLat, pointLng;
                if (RADIUS_MILES === -1) {
                    const randomDistance = Math.random() * 8000;
                    const angle = Math.random() * 2 * Math.PI;
                    pointLat = CENTER_LAT + (randomDistance / 111111) * Math.cos(angle);
                    pointLng = CENTER_LNG + (randomDistance / (111111 * Math.cos(CENTER_LAT * (Math.PI / 180)))) * Math.sin(angle);
                } else {
                    const angle = Math.random() * 2 * Math.PI;
                    const distance = Math.sqrt(Math.random()) * RADIUS_METERS;
                    pointLat = CENTER_LAT + (distance / 111111) * Math.cos(angle);
                    pointLng = CENTER_LNG + (distance / (111111 * Math.cos(CENTER_LAT * (Math.PI / 180)))) * Math.sin(angle);
                }
                locations.push({
                    lat: pointLat,
                    lng: pointLng,
                    count: Math.floor(Math.random() * 13) + 3
                });
            }
            locations.push({
                lat: CENTER_LAT + (RADIUS_METERS * 0.3 / 111111),
                lng: CENTER_LNG + (RADIUS_METERS * 0.3 / (111111 * Math.cos(CENTER_LAT * (Math.PI / 180)))),
                count: 12
            });
            const statuses = ['Open', 'In Progress', 'Closed'];
            const closureReasons = ['Cleaned', 'Item(s) Removed', 'Not Found', 'Referred to Another Department'];
            const neighborhoods = ['Mission Hill', 'Roxbury', 'Jamaica Plain'];
            locations.forEach(loc => {
                for (let i = 0; i < loc.count; i++) {
                    let reportDate;
                    const dateBias = Math.random();
                    if (dateBias < 0.5) {
                        reportDate = randomDate(moment().subtract(6, 'months'), moment());
                    } else if (dateBias < 0.8) {
                        reportDate = randomDate(moment().subtract(12, 'months'), moment().subtract(6, 'months'));
                    } else {
                        reportDate = randomDate(moment().subtract(14, 'months'), moment().subtract(12, 'months'));
                    }
                    const latVariation = (Math.random() - 0.5) * 0.0002;
                    const lngVariation = (Math.random() - 0.5) * 0.0002;
                    const status = statuses[Math.floor(Math.random() * statuses.length)];
                    const closureReason = status === 'Closed' ? 
                        closureReasons[Math.floor(Math.random() * closureReasons.length)] : '';
                    const neighborhood = neighborhoods[Math.floor(Math.random() * neighborhoods.length)];
                    sampleData.push({
                        latitude: (loc.lat + latVariation).toFixed(6),
                        longitude: (loc.lng + lngVariation).toFixed(6),
                        open_dt: reportDate.format('M/D/YYYY h:mm'),
                        case_type: 'Needle Pickup',
                        case_status: status,
                        closure_reason: closureReason,
                        neighborhood: neighborhood
                    });
                }
            });
            processData(sampleData);
        }

        // Animation Controller Class (unchanged)
        class AnimationController {
            constructor(map, options = {}) {
                this.map = map;
                this.markersGroup = options.markersGroup || L.layerGroup().addTo(map);
                this.updateInterval = options.updateInterval || 50;
                this.dayTickInterval = options.dayTickInterval || 16;
                this.isPlaying = false;
                this.startDate = null;
                this.endDate = null;
                this.currentDate = null;
                this.animationSpeed = options.initialSpeed || 1;
                this.visualUpdateTimer = null;
                this.dayTickTimer = null;
                this.lastFpsUpdate = 0;
                this.frameCount = 0;
                this.fps = 0;
                this.onVisualize = options.onVisualize || (() => {});
                this.onDateUpdate = options.onDateUpdate || (() => {});
                this.onComplete = options.onComplete || (() => {});
                this.debug = options.debug || false;
            }
            setDateRange(startDate, endDate, currentDate = null) {
                this.startDate = moment(startDate);
                this.endDate = moment(endDate);
                this.currentDate = currentDate ? moment(currentDate) : moment(startDate);
                this.updateDateDisplay();
                this.visualize();
                if (this.debug) {
                    console.log('Animation dates set:', {
                        start: this.startDate.format('YYYY-MM-DD'),
                        end: this.endDate.format('YYYY-MM-DD'),
                        current: this.currentDate.format('YYYY-MM-DD')
                    });
                }
                return this;
            }
            setSpeed(speed) {
                this.animationSpeed = speed;
                if (this.isPlaying) {
                    this.pause();
                    this.play();
                }
                return this;
            }
            jumpToDate(date) {
                this.currentDate = moment(date);
                if (this.currentDate < this.startDate) {
                    this.currentDate = moment(this.startDate);
                }
                if (this.currentDate > this.endDate) {
                    this.currentDate = moment(this.endDate);
                }
                this.updateDateDisplay();
                this.visualize();
                return this;
            }
            advanceByDays(days) {
                this.currentDate.add(days, 'days');
                if (this.currentDate > this.endDate) {
                    this.currentDate = moment(this.endDate);
                    this.pause();
                    this.onComplete();
                }
                this.updateDateDisplay();
                return this;
            }
            play() {
                if (this.isPlaying) return this;
                if (!this.startDate || !this.endDate) {
                    console.error('Cannot start animation: dates not set');
                    return this;
                }
                this.isPlaying = true;
                document.body.classList.add('animation-active');
                this.lastVisualUpdate = performance.now();
                this.visualUpdateTimer = setInterval(() => {
                    if (!document.hidden) {
                        this.visualize();
                        const now = performance.now();
                        this.frameCount++;
                        if (now - this.lastFpsUpdate > 1000) {
                            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                            this.frameCount = 0;
                            this.lastFpsUpdate = now;
                            if (this.debug) {
                                console.log(`Animation FPS: ${this.fps}`);
                            }
                        }
                    }
                }, this.updateInterval);
                this.lastDayTick = performance.now();
                this.accumulatedTime = 0;
                this.dayTickTimer = setInterval(() => {
                    if (document.hidden) return;
                    const now = performance.now();
                    const elapsed = now - this.lastDayTick;
                    this.lastDayTick = now;
                    this.accumulatedTime += elapsed;
                    const msPerDay = 1000 / this.animationSpeed;
                    if (this.accumulatedTime >= msPerDay) {
                        const daysToAdvance = this.accumulatedTime / msPerDay;
                        this.advanceByDays(daysToAdvance);
                        this.accumulatedTime = 0;
                    }
                }, this.dayTickInterval);
                return this;
            }
            pause() {
                if (!this.isPlaying) return this;
                this.isPlaying = false;
                document.body.classList.remove('animation-active');
                clearInterval(this.visualUpdateTimer);
                clearInterval(this.dayTickTimer);
                return this;
            }
            restart() {
                this.pause();
                this.jumpToDate(this.startDate);
                return this;
            }
            visualize() {
                this.onVisualize(this.currentDate);
                return this;
            }
            updateDateDisplay() {
                this.onDateUpdate(this.currentDate);
                return this;
            }
            getProgress() {
                if (!this.startDate || !this.endDate) return 0;
                const totalDays = this.endDate.diff(this.startDate, 'days');
                const elapsedDays = this.currentDate.diff(this.startDate, 'days');
                return Math.min(100, Math.max(0, (elapsedDays / totalDays) * 100));
            }
        }

        let yearlyReportsChart = null;
        function initializeYearlyChart() {
            const chartCanvas = document.getElementById('yearlyChart');
            if (!chartCanvas) {
                console.error("Chart canvas element not found!");
                return null;
            }
            if (yearlyReportsChart) {
                yearlyReportsChart.destroy();
            }
            try {
                yearlyReportsChart = new Chart(chartCanvas, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Number of Reports',
                            data: [],
                            backgroundColor: 'rgba(231, 76, 60, 0.7)',
                            borderColor: 'rgba(192, 57, 43, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Reports'
                                },
                                ticks: {
                                    precision: 0
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Year'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return 'Year: ' + tooltipItems[0].label;
                                    },
                                    label: function(context) {
                                        return 'Reports: ' + context.raw;
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 500
                        }
                    }
                });
                return yearlyReportsChart;
            } catch (error) {
                console.error("Error initializing chart:", error);
                return null;
            }
        }
        
        function updateYearlyChart(targetDate) {
            if (!allReports || allReports.length === 0) {
                return;
            }
            const reportsToDate = allReports.filter(report => report.date <= targetDate);
            const yearCounts = {};
            reportsToDate.forEach(report => {
                const year = report.date.year();
                yearCounts[year] = (yearCounts[year] || 0) + 1;
            });
            const years = Object.keys(yearCounts).sort();
            const counts = years.map(year => yearCounts[year]);
            if (!yearlyReportsChart) {
                yearlyReportsChart = initializeYearlyChart();
            }
            yearlyReportsChart.data.labels = years;
            yearlyReportsChart.data.datasets[0].data = counts;
            const isAnimating = animationController && animationController.isPlaying;
            yearlyReportsChart.options.animation.duration = isAnimating ? 0 : 500;
            yearlyReportsChart.update('none');
        }
        
        function visualizeDataAtDate(targetDate) {
            markersGroup.clearLayers();
            let activeLocationCount = 0;
            let recentReportCount = 0;
            let totalReportCount = 0;
            reportsByLocation.forEach((locationData, locationKey) => {
                const relevantReports = locationData.reports.filter(report => 
                    report.date <= targetDate
                );
                if (relevantReports.length === 0) return;
                if (!animationController.isPlaying) {
                    relevantReports.sort((a, b) => a.date - b.date);
                }
                const latestReportDate = relevantReports[relevantReports.length - 1].date;
                const isActive = targetDate.diff(latestReportDate, 'months', true) <= 12;
                if (isActive) activeLocationCount++;
                const recentLocationReports = relevantReports.filter(report => 
                    targetDate.diff(report.date, 'days', true) <= 30
                ).length;
                recentReportCount += recentLocationReports;
                totalReportCount += relevantReports.length;
                const radius = Math.min(60, Math.max(5, 5 + relevantReports.length * 1.5));
                const monthsSinceLatest = targetDate.diff(latestReportDate, 'months', true);
                const opacity = Math.max(0.2, 1 - (monthsSinceLatest / 12));
                const circle = L.circleMarker([locationData.lat, locationData.lng], {
                    radius: radius,
                    fillColor: '#e74c3c',
                    color: '#c0392b',
                    weight: 1,
                    opacity: opacity,
                    fillOpacity: opacity
                });
                if (!animationController.isPlaying) {
                    let popupContent = `<b>${relevantReports.length} needle report(s)</b><br>
                                   Latest: ${latestReportDate.format('MMM D, YYYY')}<br>
                                   First: ${relevantReports[0].date.format('MMM D, YYYY')}<br><br>`;
                    const displayReports = relevantReports.length > 5 ? 
                        [...relevantReports.slice(-5).reverse()] :
                        [...relevantReports.reverse()];
                    displayReports.forEach(report => {
                        popupContent += `<div style="margin-bottom:5px; border-bottom:1px solid #eee; padding-bottom:5px;">
                                        <b>${report.date.format('MMM D, YYYY h:mm A')}</b><br>`;
                        if (report.data.case_status) {
                            popupContent += `Status: ${report.data.case_status}<br>`;
                        }
                        if (report.data.closure_reason) {
                            popupContent += `Closure: ${report.data.closure_reason}<br>`;
                        }
                        if (report.data.neighborhood) {
                            popupContent += `Neighborhood: ${report.data.neighborhood}<br>`;
                        }
                        popupContent += `</div>`;
                    });
                    if (relevantReports.length > 5) {
                        popupContent += `<i>And ${relevantReports.length - 5} more reports...</i>`;
                    }
                    circle.bindPopup(popupContent);
                } else {
                    circle.bindPopup(`${relevantReports.length} needle reports here`);
                }
                markersGroup.addLayer(circle);
            });

            document.getElementById('totalReports').textContent = totalReportCount;
            document.getElementById('activeLocations').textContent = activeLocationCount;
            document.getElementById('recentReports').textContent = recentReportCount;
            const markersToggle = document.getElementById('toggleMarkers');
			if (markersToggle.checked) {
				// Only add the legend if it doesn't exist already.
				if (!document.getElementById('map').querySelector('.legend')) {
					addLegend();
				}
			} else {
				// If the markers toggle is unchecked, remove any existing legend.
				if (map.legend) {
					map.legend.remove();
					map.legend = null;
				}
			}
            updateYearlyChart(targetDate);

            // --- Heatmap update ---
            if (document.getElementById('toggleHeatmap').checked) {
                let heatData = [];
                allReports.forEach(report => {
                    if (report.date <= targetDate) {
                        let daysDiff = targetDate.diff(report.date, 'days', true);
                        let weight = Math.max(0, 1 - (daysDiff / 365));
                        if (weight > 0) {
                            heatData.push([
                                parseFloat(report.data.latitude),
                                parseFloat(report.data.longitude),
                                weight
                            ]);
                        }
                    }
                });
                heatLayer.setLatLngs(heatData);
            }
        }

        const animationController = new AnimationController(map, {
            markersGroup: markersGroup,
            initialSpeed: 1,
            updateInterval: 50,
            dayTickInterval: 16,
            debug: false,
            onVisualize: function(date) {
                visualizeDataAtDate(date);
            },
            onDateUpdate: function(date) {
                document.getElementById('currentDate').textContent = date.format('MMM D, YYYY');
                document.getElementById('timeSlider').value = date.diff(animationController.startDate, 'days');
            },
            onComplete: function() {
                document.getElementById('playButton').disabled = false;
                document.getElementById('pauseButton').disabled = true;
            }
        });
        
        document.getElementById('playButton').addEventListener('click', function() {
            animationController.play();
            document.getElementById('playButton').disabled = true;
            document.getElementById('pauseButton').disabled = false;
        });
        
        document.getElementById('pauseButton').addEventListener('click', function() {
            animationController.pause();
            document.getElementById('playButton').disabled = false;
            document.getElementById('pauseButton').disabled = true;
        });
        
        document.getElementById('restartButton').addEventListener('click', function() {
            animationController.restart();
            document.getElementById('playButton').disabled = false;
            document.getElementById('pauseButton').disabled = true;
        });
        
        document.getElementById('timeSlider').addEventListener('input', function(e) {
            animationController.pause();
            const daysFromStart = parseInt(e.target.value);
            animationController.jumpToDate(moment(startDate).add(daysFromStart, 'days'));
            document.getElementById('playButton').disabled = false;
            document.getElementById('pauseButton').disabled = true;
        });
        
        document.getElementById('speedControl').addEventListener('change', function(e) {
            animationController.setSpeed(parseFloat(e.target.value));
        });
        
        window.addEventListener('resize', function() {
            setTimeout(() => {
                map.invalidateSize();
            }, 100);
        });
        
        setTimeout(() => {
            map.invalidateSize();
        }, 100);
        
        // Automatically load "needles_all.csv" on page load
        Papa.parse("needles_all.csv", {
            download: true,
            header: true,
            complete: function(results) {
                csvData = results.data;
                processData(csvData);
            },
            error: function(error) {
                console.error('Error parsing CSV:', error);
                alert('Error loading needles_all.csv. Please check the file and try again.');
            }
        });
    </script>
</body>
</html>
